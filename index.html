<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UCL Draw — Standalone</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg0:#050a22; --bg1:#0a1542; --accA:#0232FF; --accB:#7a3cff; --accC:#00eeff; --card:rgba(255,255,255,.06); --border:rgba(255,255,255,.18); --txt:#ffffff }
    *{box-sizing:border-box}
    body{margin:0; color:var(--txt); background:
      radial-gradient(900px 520px at 10% -10%, rgba(122,60,255,.35), transparent 60%),
      radial-gradient(700px 420px at 110% 10%, rgba(0,238,255,.35), transparent 60%),
      linear-gradient(180deg, var(--bg1) 0%, var(--bg0) 70%);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    .wrap{max-width:1120px; margin:0 auto; padding:16px}
    .h-display{font-family:'Barlow Condensed', Inter, sans-serif; letter-spacing:.02em; color:#fff}
    .tile{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.12); border-radius:14px}
    .tile.highlight{ border-color: rgba(0,238,255,.8); box-shadow: 0 0 0 2px rgba(0,238,255,.35), 0 0 32px rgba(0,238,255,.25), inset 0 0 24px rgba(2,50,255,.18); animation: glow 2.4s ease-in-out infinite alternate }
    @keyframes glow{ from{ box-shadow: 0 0 0 2px rgba(0,238,255,.25), 0 0 18px rgba(0,238,255,.18), inset 0 0 12px rgba(2,50,255,.12)} to{ box-shadow: 0 0 0 2px rgba(0,238,255,.45), 0 0 36px rgba(0,238,255,.30), inset 0 0 24px rgba(2,50,255,.22)} }
    .bar{background:linear-gradient(90deg, var(--accA), var(--accC)); color:#fff; border-radius:10px; font-weight:800}
    .btn{border-radius:9999px; padding:.85rem 1.4rem; font-weight:800; font-family:'Barlow Condensed', Inter; letter-spacing:.02em; border:none; 
      background:linear-gradient(90deg,var(--accA),var(--accB)); color:#fff; box-shadow:0 10px 24px rgba(0,0,0,.35); cursor:pointer; transition:transform .08s ease, box-shadow .2s ease}
    .btn:hover{box-shadow:0 12px 28px rgba(0,0,0,.45)}
    .btn:active{transform:translateY(1px) scale(.98)}
    .btn:focus-visible{outline:3px solid rgba(0,238,255,.6); outline-offset:2px}
    .btn-glow{ animation: btnpulse 1.3s ease-in-out infinite; box-shadow:0 0 0 0 rgba(0,238,255,.45), 0 0 22px rgba(0,238,255,.35) }
    @keyframes btnpulse{ 0%{ box-shadow:0 0 0 0 rgba(0,238,255,.45), 0 0 22px rgba(0,238,255,.35)} 100%{ box-shadow:0 0 0 12px rgba(0,238,255,0), 0 0 10px rgba(0,238,255,.15)} }
    .chooser{max-width:760px; margin:0 auto}
    .input{width:100%; padding:.8rem 1rem; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.18); color:#fff}
    .input::placeholder{ color: rgba(255,255,255,.55) }
    .suggest{position:absolute; z-index:20; width:100%; background:rgba(4,17,42,.96); border:1px solid rgba(255,255,255,.12); border-radius:12px; overflow:hidden; max-height:320px; overflow-y:auto}
    .suggest li{padding:.55rem .8rem; cursor:pointer}
    .suggest li:hover{background:rgba(255,255,255,.06)}
    .row{display:flex; gap:8px; align-items:center}
    .center{display:flex; flex-direction:column; align-items:center}
    .mb2{margin-bottom:8px} .mb3{margin-bottom:12px} .mb4{margin-bottom:16px}
    .tag{font-size:11px; padding:.1rem .35rem; border-radius:6px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12)}
    .haTag{width:24px; height:18px; border-radius:4px; display:grid; place-items:center; font-weight:800; font-size:12px}
    .h{background:#1e4bff} .a{background:#00b2ff}
    .grid{display:grid; gap:16px}
    @media(min-width:640px){ .grid.cols-2{grid-template-columns:1fr 1fr} }
    @media(min-width:1024px){ .grid.cols-3{grid-template-columns:1fr 1fr 1fr} }
    .crest{width:18px; height:18px; border-radius:4px; object-fit:contain; background:transparent}
    .error{color:#ffd0d0; background:rgba(255,0,0,.1); border:1px solid rgba(255,0,0,.25); padding:8px 12px; border-radius:12px; text-align:center}
    .star{position:absolute; opacity:.16; filter: drop-shadow(0 0 10px rgba(255,255,255,.25))}
    .reveal{animation: pop .28s cubic-bezier(.2,1,.2,1)}
    @keyframes pop{ from{ transform: scale(.96); opacity:.4 } to{ transform: scale(1); opacity:1 } }
    .pin{max-width:44rem; margin: 0 auto 12px auto}
  </style>
</head>
<body>
  <img class="star" src="https://upload.wikimedia.org/wikipedia/en/thumb/9/9e/UEFA_Champions_League_logo_2.svg/120px-UEFA_Champions_League_logo_2.svg.png" style="top:18px;left:18px;width:80px;height:80px" alt="starball"/>
  <img class="star" src="https://upload.wikimedia.org/wikipedia/en/thumb/f/f1/UEFA_Champions_League.svg/120px-UEFA_Champions_League.svg.png" style="bottom:18px;right:18px;width:90px;height:90px" alt="starball"/>

  <div class="wrap">
    <!-- chooser -->
    <div class="center mb4">
      <div class="chooser" style="position:relative; width:100%">
        <label class="mb2" style="display:block; font-size:12px; opacity:.9">Your Team</label>
        <input id="teamInput" class="input" placeholder="Type to search (e.g. Gala...)" />
        <ul id="suggestList" class="suggest" style="display:none; margin-top:8px"></ul>
      </div>
      <button id="startBtn" class="btn btn-glow" style="margin-top:12px">Start</button>
      <div id="selectedNote" style="font-size:12px; opacity:.8; margin-top:6px"></div>
    </div>

    <div id="errorBox" class="error" style="display:none"></div>

    <div id="focusMount"></div>
    <div id="allMount"></div>
  </div>

<script>
// ----- DATA (official 36) -----
const TEAMS_36 = [
  // Pot 1
  { name: 'Paris Saint-Germain', country: 'FRA', pot: 1 },
  { name: 'Real Madrid', country: 'ESP', pot: 1 },
  { name: 'Manchester City', country: 'ENG', pot: 1 },
  { name: 'Bayern München', country: 'GER', pot: 1 },
  { name: 'Liverpool', country: 'ENG', pot: 1 },
  { name: 'Inter', country: 'ITA', pot: 1 },
  { name: 'Chelsea', country: 'ENG', pot: 1 },
  { name: 'Borussia Dortmund', country: 'GER', pot: 1 },
  { name: 'Barcelona', country: 'ESP', pot: 1 },
  // Pot 2
  { name: 'Arsenal', country: 'ENG', pot: 2 },
  { name: 'Bayer Leverkusen', country: 'GER', pot: 2 },
  { name: 'Atlético Madrid', country: 'ESP', pot: 2 },
  { name: 'Benfica', country: 'POR', pot: 2 },
  { name: 'Atalanta', country: 'ITA', pot: 2 },
  { name: 'Villarreal', country: 'ESP', pot: 2 },
  { name: 'Juventus', country: 'ITA', pot: 2 },
  { name: 'Eintracht Frankfurt', country: 'GER', pot: 2 },
  { name: 'Club Brugge', country: 'BEL', pot: 2 },
  // Pot 3
  { name: 'Tottenham Hotspur', country: 'ENG', pot: 3 },
  { name: 'PSV Eindhoven', country: 'NED', pot: 3 },
  { name: 'Ajax', country: 'NED', pot: 3 },
  { name: 'Napoli', country: 'ITA', pot: 3 },
  { name: 'Sporting CP', country: 'POR', pot: 3 },
  { name: 'Olympiacos', country: 'GRE', pot: 3 },
  { name: 'Slavia Praha', country: 'CZE', pot: 3 },
  { name: 'Bodø/Glimt', country: 'NOR', pot: 3 },
  { name: 'Marseille', country: 'FRA', pot: 3 },
  // Pot 4
  { name: 'Copenhagen', country: 'DEN', pot: 4 },
  { name: 'Monaco', country: 'FRA', pot: 4 },
  { name: 'Galatasaray', country: 'TUR', pot: 4 },
  { name: 'Union SG', country: 'BEL', pot: 4 },
  { name: 'Qarabağ', country: 'AZE', pot: 4 },
  { name: 'Athletic Club', country: 'ESP', pot: 4 },
  { name: 'Newcastle United', country: 'ENG', pot: 4 },
  { name: 'Pafos', country: 'CYP', pot: 4 },
  { name: 'Kairat Almaty', country: 'KAZ', pot: 4 },
];

// ----- CRESTS mapping to your filenames -----
const CREST_BASE = './crests';
const CREST_MAP = {
  'Paris Saint-Germain': 'psg',
  'Real Madrid': 'real',
  'Manchester City': 'city',
  'Bayern München': 'bayern',
  'Liverpool': 'lfc',
  'Inter': 'inter',
  'Chelsea': 'cfc',
  'Borussia Dortmund': 'bvb',
  'Barcelona': 'barcelona',
  'Arsenal': 'arsenal',
  'Bayer Leverkusen': 'bayer',
  'Atlético Madrid': 'atleti',
  'Benfica': 'benfica',
  'Atalanta': 'atalanta',
  'Villarreal': 'villareal', // you saved as villareal.png
  'Juventus': 'juve',
  'Eintracht Frankfurt': 'frankfurt',
  'Club Brugge': 'brugge',
  'Tottenham Hotspur': 'spurs',
  'PSV Eindhoven': 'psv',
  'Ajax': 'ajax',
  'Napoli': 'napoli',
  'Sporting CP': 'sporting',
  'Olympiacos': 'olympiacos',
  'Slavia Praha': 'slavia',
  'Bodø/Glimt': 'bodo',
  'Marseille': 'marseille',
  'Copenhagen': 'copenhagen', 'FC København': 'copenhagen',
  'Monaco': 'monaco', 'AS Monaco': 'monaco',
  'Galatasaray': 'gs',
  'Union SG': 'union',
  'Qarabağ': 'qarabag', 'Qarabag': 'qarabag',
  'Athletic Club': 'athletic',
  'Newcastle United': 'newcastle',
  'Pafos': 'pafos',
  'Kairat Almaty': 'kairat',
};
function crestUrl(name){ const slug = CREST_MAP[name]; return slug? `${CREST_BASE}/${slug}.png` : `${CREST_BASE}/missing.png`; }

// ----- UTILS -----
const norm = (s='') => s.normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
const byPot = (teams) => { const p=[[],[],[],[]]; teams.forEach(t=>p[t.pot-1].push(t)); return p; };
const rngFactory = (seed) => { let s=(seed>>>0)||1; return ()=> (s=(1664525*s+1013904223)>>>0, s/2**32); };

// ----- PAIRINGS with exact H/A via 2-SAT -----
function buildPairings(teams, tries = 300, seedBase = Date.now()){
  const NEEDED_PER_POT = 2; const allPots=[1,2,3,4];
  const idxByPotInit = byPot(teams);
  const countryFreq = {}; teams.forEach(t=> countryFreq[t.country]=(countryFreq[t.country]||0)+1);

  function attempt(seed){
    const r = rngFactory(seed);
    const need = new Map(); const assoc = new Map(); const opp = new Map(); const byName = new Map();
    const idxByPot = {1:[],2:[],3:[],4:[]};
    teams.forEach(t=>{ need.set(t.name,{1:2,2:2,3:2,4:2}); assoc.set(t.name,{}); opp.set(t.name,new Set()); byName.set(t.name,t); });
    allPots.forEach(p=> idxByPot[p] = [...idxByPotInit[p-1]]);

    const tasks = []; for(const t of teams){ for(const p of allPots){ tasks.push([t,p]); tasks.push([t,p]); } }

    function canPair(a,b,p){
      if(a.name===b.name) return false;
      if(a.country===b.country) return false;
      if(opp.get(a.name).has(b.name)) return false;
      if((assoc.get(a.name)[b.country]||0)>=2) return false;
      if((assoc.get(b.name)[a.country]||0)>=2) return false;
      if(need.get(a.name)[p]<=0) return false;
      if(need.get(b.name)[a.pot]<=0) return false;
      return true;
    }
    function candidatesFor(t,p){
      const list = idxByPot[p]; const out=[];
      for(const c of list){ if(canPair(t,c,p)) out.push(c); }
      out.sort((A,B)=>{
        const aNeed = need.get(A.name)[t.pot]; const bNeed = need.get(B.name)[t.pot]; if(aNeed!==bNeed) return aNeed-bNeed;
        const aAssoc = assoc.get(A.name)[t.country]||0; const bAssoc = assoc.get(B.name)[t.country]||0; if(aAssoc!==bAssoc) return aAssoc-bAssoc;
        const ar = countryFreq[A.country], br = countryFreq[B.country]; if(ar!==br) return ar-br; return r()<0.5 ? -1 : 1;
      });
      return out;
    }
    function place(a,b){
      opp.get(a.name).add(b.name); opp.get(b.name).add(a.name);
      need.get(a.name)[b.pot]--; need.get(b.name)[a.pot]--;
      assoc.get(a.name)[b.country]=(assoc.get(a.name)[b.country]||0)+1;
      assoc.get(b.name)[a.country]=(assoc.get(b.name)[a.country]||0)+1;
    }

    for(let step=0; step<tasks.length; step++){
      let bestIdx=-1, bestCnt=1e9, bestCands=null;
      for(let i=0;i<tasks.length;i++){
        const item = tasks[i]; if(!item) continue; const [t,p]=item;
        if(need.get(t.name)[p]<=0){ tasks[i]=null; continue; }
        const cands = candidatesFor(t,p); const cnt=cands.length; if(cnt===0) return null;
        if(cnt<bestCnt){ bestCnt=cnt; bestIdx=i; bestCands=cands; if(cnt===1) break; }
      }
      if(bestIdx<0) break;
      const [t,p]=tasks[bestIdx];
      const pick = bestCands[Math.floor(Math.random()*Math.min(bestCands.length,3))];
      place(t,pick); tasks[bestIdx]=null;
    }

    const table = teams.map(t=>{
      const res={team:t,pots:{1:[],2:[],3:[],4:[]}};
      for(const oname of opp.get(t.name)){ res.pots[ byName.get(oname).pot ].push(oname); }
      for(const q of allPots){ if(res.pots[q].length!==NEEDED_PER_POT) return null; }
      return res;
    });
    if(table.some(x=>!x)) return null;

    // H/A with 2-SAT (exactly one Home per pot among its two vs that pot)
    const edgeKeys = []; const varOf = new Map();
    const pushKey = (a,b)=>{ const key = a<b ? `${a}__${b}` : `${b}__${a}`; if(!varOf.has(key)){ varOf.set(key, edgeKeys.length); edgeKeys.push(key); } };
    for(const row of table){ for(const p of allPots){ for(const oname of row.pots[p]) pushKey(row.team.name, oname); }}
    const M = edgeKeys.length; const N = M*2; const adj = Array.from({length:N},()=>[]), radj=Array.from({length:N},()=>[]);
    const lit = (team, other)=>{ const a = team<other ? team : other; const b = team<other ? other : team; const v = varOf.get(`${a}__${b}`); const neg = team!==a; return {v,neg}; };
    const node = (x)=> x.v*2 + (x.neg?1:0); const neg = (x)=> ({v:x.v, neg:!x.neg});
    const imply=(u,v)=>{ adj[node(u)].push(node(v)); radj[node(v)].push(node(u)); };
    const addOr=(u,v)=>{ imply(neg(u),v); imply(neg(v),u); };
    const addXor=(u,v)=>{ addOr(u,v); addOr(neg(u),neg(v)); };

    for(const row of table){ const t=row.team.name; for(const p of allPots){ const opps=row.pots[p]; if(opps.length!==2) return null; const [o1,o2]=opps; addXor(lit(t,o1), lit(t,o2)); } }

    const order=[]; const used=Array(N).fill(false);
    const dfs1=(u)=>{ used[u]=true; for(const v of adj[u]) if(!used[v]) dfs1(v); order.push(u); };
    for(let i=0;i<N;i++) if(!used[i]) dfs1(i);
    const comp=Array(N).fill(-1); let j=0; const dfs2=(u,c)=>{ comp[u]=c; for(const v of radj[u]) if(comp[v]===-1) dfs2(v,c); };
    for(let i=N-1;i>=0;i--){ const v=order[i]; if(comp[v]===-1) dfs2(v,j++); }
    const assign=Array(M).fill(false);
    for(let v=0; v<M; v++){ if(comp[2*v]===comp[2*v+1]) return null; assign[v]= comp[2*v] > comp[2*v+1]; }

    const tableHA = table.map(row=>{
      const list=[]; const name=row.team.name;
      for(const p of allPots){ for(const oname of row.pots[p]){
        const a = name<oname ? name : oname; const b = name<oname ? oname : name; const varId = varOf.get(`${a}__${b}`); const firstHome = assign[varId];
        const isHome = (name===a) ? firstHome : !firstHome; list.push({ opponent:oname, pot:p, home:isHome });
      }}
      list.sort((A,B)=> A.pot-B.pot || A.opponent.localeCompare(B.opponent));
      return { team: row.team, fixtures: list };
    });

    return { ok:true, table: tableHA };
  }

  for(let k=0;k<tries;k++){ const res = attempt(seedBase + k*7919); if(res) return res; }
  return { ok:false, error:`Could not find a valid pairing after ${tries} attempts.` };
}

// ----- UI helpers -----
const $ = (sel) => document.querySelector(sel);
function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }

function teamPanel(row, highlight=false){
  const box = document.createElement('div'); box.className = 'tile p-3'; box.style.padding='12px'; if(highlight) box.classList.add('highlight');
  const list = document.createElement('ul'); list.style.listStyle='none'; list.style.padding=0; list.style.margin='0 0 12px 0';
  row.fixtures.forEach(f=>{
    const li = document.createElement('li'); li.className='row'; li.style.justifyContent='space-between'; li.style.padding='6px 8px'; li.style.border='1px solid rgba(255,255,255,.1)'; li.style.borderRadius='10px'; li.style.margin='4px 0';
    const left = document.createElement('div'); left.className='row'; left.style.minWidth='0';
    const img = document.createElement('img'); img.className='crest'; img.loading='lazy'; img.src=crestUrl(f.opponent); img.alt=f.opponent; img.onerror=()=>{ img.src = CREST_BASE + '/missing.png'; };
    const nameSpan = document.createElement('span'); nameSpan.textContent=f.opponent; nameSpan.style.whiteSpace='nowrap'; nameSpan.style.overflow='hidden'; nameSpan.style.textOverflow='ellipsis';
    const tag = document.createElement('span'); tag.className='tag'; tag.textContent='Pot ' + f.pot; tag.style.marginLeft='8px';
    left.append(img, nameSpan, tag);
    const ha = document.createElement('div'); ha.className = 'haTag ' + (f.home?'h':'a'); ha.textContent = f.home? 'H':'A';
    li.append(left, ha); list.appendChild(li);
  });
  const bar = document.createElement('div'); bar.className='bar row'; bar.style.padding='10px 12px'; bar.style.gap='8px'; bar.style.alignItems='center';
  const timg = document.createElement('img'); timg.className='crest'; timg.src=crestUrl(row.team.name); timg.alt=row.team.name; timg.onerror=()=>{ timg.src = CREST_BASE + '/missing.png'; };
  const tname = document.createElement('div'); tname.className='h-display'; tname.style.fontSize='18px'; tname.style.overflow='hidden'; tname.style.textOverflow='ellipsis'; tname.textContent=row.team.name;
  bar.append(timg, tname);
  box.append(list, bar);
  return box;
}

function focusPanel(row, revealedNames){
  const box = document.createElement('div'); box.className='center';
  const tile = document.createElement('div'); tile.className='tile highlight'; tile.style.padding='12px'; tile.style.maxWidth='720px'; tile.style.width='100%';
  const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding=0; ul.style.margin='0 0 12px 0';
  row.fixtures.filter(f=>revealedNames.includes(f.opponent)).sort((A,B)=> A.pot-B.pot || A.opponent.localeCompare(B.opponent)).forEach(f=>{
    const li = document.createElement('li'); li.className='row reveal'; li.style.justifyContent='space-between'; li.style.padding='6px 8px'; li.style.border='1px solid rgba(255,255,255,.1)'; li.style.borderRadius='10px'; li.style.margin='4px 0';
    const left = document.createElement('div'); left.className='row'; left.style.minWidth='0';
    const img = document.createElement('img'); img.className='crest'; img.src=crestUrl(f.opponent); img.alt=f.opponent; img.onerror=()=>{ img.src=CREST_BASE+'/missing.png'; };
    const span = document.createElement('span'); span.textContent=f.opponent; span.style.whiteSpace='nowrap'; span.style.overflow='hidden'; span.style.textOverflow='ellipsis';
    const tag = document.createElement('span'); tag.className='tag'; tag.textContent='Pot ' + f.pot; tag.style.marginLeft='8px';
    const ha = document.createElement('div'); ha.className='haTag ' + (f.home?'h':'a'); ha.textContent=f.home?'H':'A';
    left.append(img, span, tag); li.append(left, ha); ul.appendChild(li);
  });
  const bar = document.createElement('div'); bar.className='bar row'; bar.style.padding='10px 12px'; bar.style.gap='8px'; bar.style.alignItems='center';
  const timg = document.createElement('img'); timg.className='crest'; timg.src=crestUrl(row.team.name); timg.alt=row.team.name; timg.onerror=()=>{ timg.src=CREST_BASE+'/missing.png'; };
  const tname = document.createElement('div'); tname.className='h-display'; tname.style.fontSize='18px'; tname.textContent=row.team.name;
  bar.append(timg, tname);
  tile.append(ul, bar); box.appendChild(tile); return box;
}

// ----- STATE -----
let selected = '';
let res = null; // { ok, table }
let phase = 'idle'; // idle | focus | all
let revealed = [];
let revealToken = 0;
let startGlow = true;

// ----- TYPEAHEAD -----
const input = $('#teamInput');
const listEl = $('#suggestList');

function currentSuggestions(){ const q=norm(input.value); if(!q) return TEAMS_36; return TEAMS_36.filter(t=> norm(t.name).startsWith(q)); }
function openSuggest(){ const sug = currentSuggestions(); fillSuggest(sug); listEl.style.display = 'block'; }
function closeSuggest(){ listEl.style.display = 'none'; }
function fillSuggest(items){ clear(listEl); items.slice(0,36).forEach(t=>{ const li=document.createElement('li'); li.textContent = `${t.name} (${t.country})`; li.onmousedown = (e)=>{ e.preventDefault(); pickTeam(t.name); closeSuggest(); }; listEl.appendChild(li); }); }
function pickTeam(name){ selected = name; input.value = name; $('#selectedNote').textContent = 'Selected: ' + name; if(res){ if(phase==='focus'){ runFocusReveal(name, res.table); } else { phase='all'; renderAll(); } } }

input.addEventListener('focus', ()=> openSuggest());
input.addEventListener('blur', ()=> setTimeout(closeSuggest, 60));
input.addEventListener('input', ()=>{ const sug = currentSuggestions(); fillSuggest(sug); listEl.style.display = 'block'; });
input.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){ e.preventDefault(); const q=norm(input.value); const exact = TEAMS_36.find(t=> norm(t.name)===q); if(exact) pickTeam(exact.name); else { const sug=currentSuggestions(); if(sug.length>0) pickTeam(sug[0].name); } closeSuggest(); }
  if(e.key==='Escape'){ closeSuggest(); }
});

// ----- RENDER MOUNTS -----
const focusMount = $('#focusMount');
const allMount = $('#allMount');
const errorBox = $('#errorBox');

function showError(msg){ errorBox.textContent = msg; errorBox.style.display = 'block'; }
function clearError(){ errorBox.style.display = 'none'; errorBox.textContent=''; }

function renderFocus(row){ clear(focusMount); clear(allMount); focusMount.appendChild(focusPanel(row, revealed)); }
function renderAll(){ clear(focusMount); clear(allMount); if(!res) return; const pinned = res.table.find(r=> r.team.name===selected) || res.table[0]; if(!pinned) return; const others = res.table.filter(r=> r!==pinned);
  const pinWrap = document.createElement('div'); pinWrap.className = 'pin'; pinWrap.appendChild(teamPanel(pinned, true)); allMount.appendChild(pinWrap);
  const grid = document.createElement('div'); grid.className = 'grid cols-1 cols-2 cols-3'; allMount.appendChild(grid);
  others.forEach(row=> grid.appendChild(teamPanel(row, false))); }

// ----- REVEAL -----
function runFocusReveal(name, tableSrc){ if(!tableSrc) return; const focusRow = tableSrc.find(r=> r.team.name===name); if(!focusRow){ showError('Selected team not found.'); return; }
  phase='focus'; revealed=[]; revealToken++; const token = revealToken; clearError(); renderFocus(focusRow);
  const ordered = [...focusRow.fixtures].sort((A,B)=> A.pot-B.pot || A.opponent.localeCompare(B.opponent));
  ordered.forEach((f,idx)=>{ setTimeout(()=>{ if(revealToken!==token) return; revealed.push(f.opponent); renderFocus(focusRow); if(revealed.length>=8){ phase='all'; renderAll(); } }, 650*(idx+1)); }); }

// ----- START -----
const startBtn = $('#startBtn');
startBtn.addEventListener('click', ()=>{
  clearError(); if(startGlow){ startBtn.classList.remove('btn-glow'); startGlow=false; }
  const chosen = selected || (currentSuggestions()[0]?.name || ''); if(!chosen){ showError('Please type and pick a team.'); return; }
  const out = buildPairings(TEAMS_36, 500); if(!out || !out.ok){ showError(out?.error || 'Pairing failed.'); return; }
  res = out; runFocusReveal(chosen, out.table);
});
</script>
</body>
</html>
